# Java

## Java 基础

### 1. Java 常用的数据结构
1) 数组
2) Collection -> List (ArrayList, LinkedList), Set(HashSet 基于 HashMap 实现, TreeSet 基于 TreeMap),
   Queue (LinkedBlockingQueue, Executors 中使用 LinkedBlockingQueue 实现 FixedThreadPool)
3) Map -> HashMap, TreeMap, LinkedHashMap (LRU cache), WeakHashMap, ConcurrentHashMap

### 2. JVM 
1) JVM 内存模型：方法区（存放类信息、常量、静态变量，运行时的常量池也是位于方法区，Hotspot虚拟机在java 8之前，以
   永久代的形式实现方法区，在 full GC 时进行垃圾回收；java 8 开始，使用元数据取代了永久代）、堆区（存放类实例，是
   GC 的主要对象）、栈区(线程私有，存放一个个的栈帧，当线程调用一个 java 方法时，jvm 将存放相应方法信息的栈帧 push 
   到线程的方法栈)、程序计数器（线程私有，当前线程所执行的字节码指针）、本地方法栈
2) 类加载过程：一个类从被加载到虚拟机内存中开始，到卸载出内存为止，它的生命周期包括加载（找到类，并将类二进制码加载到方法区）、
   验证（验证类的正确性）、准备（为类变量分配内存并初始化）、解析（将符号引用转变为直接引用）、初始化（执行类提供的初始化代码，
   初始化类变量）、使用和卸载。加载、验证、准备、解析和初始化过程由类加载器负责。JVM 有四种类加载器，即启动类加载器、扩展类
   加载器、应用程序类加载器和用户自定义类加载器。类加载器之间应用双亲委派机制加载类。
3) GC：通过引用计数和可达性分析确定哪些是待回收的垃圾对象，采用标记-清除算法（实现简单，但会产生内存碎片）、复制算法、标记-整理算法（解
   决内存碎片问题，但是垃圾回收代价大）或分代收集算法（目前主流的 GC 策略）中的一种。
   示例：java -Xmx3550m -Xms3550m -Xmn2g -Xss128k
   解析：-Xmx 设置 jvm 最大堆内存；-Xms 设置初始堆内存，一般和最大可用内存一样；-Xmn 设置年轻代大小；-Xss 设置每个线程的栈大小

## 网络基础

### 1. HTTP和TCP协议
1) HTTP/S 超级文本传输协议，定义OSI七层网络模型中应用层的数据传输标准。POST请求常与 GET 请求
   
2) TCP/IP 协议定义在OSI网络模型中的传输层，是一种提供可靠通信的网络传输协议。TCP 协议为了保证服务端能收接受到客户端的信息并能做出
   正确的应答而进行前两次(第一次和第二次)握手，为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行后两次(第二次和第三次)握手。
   TCP三次握手是"在不可靠的信道上可靠地传输信息"这一需求导致的。
   套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的
   五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。
   TCP四次挥手：由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。服务器B收到
   这个FIN，它发回一个ACK，确认序号为收到的序号加1。服务器B关闭与客户端A的连接，发送一个FIN给客户端A。客户端A发回ACK报文确认，并将确认
   序号设置为收到序号加1。

